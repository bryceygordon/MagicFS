# ðŸ›ï¸ MagicFS Persistence & Semantic Graph Specification

> "The Database IS the Filesystem."

This document defines the architecture for **Phase 12 (Organization)** and the future **Semantic Thin Client**. It outlines a system where files are abstract objects and directories are dynamic queries (Tags), decoupled from physical storage.

---

## 1. Core Architecture: The "Object Store & View" Model

MagicFS separates the **Physical Existence** of a file from its **Logical Organization**.

### A. The Warehouse (Physical Storage)
* **Location:** `~/.magicfs/storage/` (or watched external paths).
* **Role:** Dumb block storage. A flat list of files (hashed or sequentially named).
* **User Access:** Rarely accessed directly.

### B. The Lens (Logical Views)
* **Location:** `/magic/tags/`, `/magic/inbox/`, `/magic/trash/`.
* **Role:** Dynamic views generated by database queries.
* **Technology:** Virtual Inodes (Passthrough), **NOT** Symlinks. This allows a single file to have different names in different folders ("The Multiverse").

---

## 2. The Inode Router (Addressing)

To manage persistence without state duplication, `InodeStore` acts as a router based on the Inode ID bit-space.

| Zone | Range | Backend | Purpose |
| :--- | :--- | :--- | :--- |
| **System** | `1 - 100` | Hardcoded | Root, `.magic`, `/search`, `/tags` |
| **Transient** | `101 - 9.22e18` | `BTreeMap` (RAM) | Active Searches, Mirror Cache |
| **Persistent** | `> 9.22e18` | `sqlite3` | Saved Tags, Inbox, Trash |

**The Switch:**
* `lookup(id)` checks the High Bit.
* **Low Bit:** Served from RAM (Fast, Ephemeral).
* **High Bit:** Served from SQLite `tags` or `file_tags` tables (Durable).

---

## 3. Database Schema

### Table: `files` (The Warehouse Registry)
The source of truth for physical files.
```sql
CREATE TABLE files (
    file_id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- Physical Location (Pointer)
    abs_path TEXT NOT NULL UNIQUE,
    
    -- Content Identity (Deduplication)
    content_hash TEXT, 
    size INTEGER,
    
    created_at INTEGER DEFAULT (unixepoch())
);
```

### Table: `tags` (The Taxonomy)
Represents the folder structure under `/magic/tags`.
```sql
CREATE TABLE tags (
    tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
    parent_tag_id INTEGER, -- For nested tags (Finance -> 2024)
    name TEXT NOT NULL,
    color TEXT,
    icon TEXT,
    
    UNIQUE(parent_tag_id, name),
    FOREIGN KEY(parent_tag_id) REFERENCES tags(tag_id)
);
```

### Table: `file_tags` (The Edges)
Connects Files to Tags. This is where "Copy" and "Move" happen.
```sql
CREATE TABLE file_tags (
    file_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    
    -- The Multiverse: A file can have a different name in this specific tag view
    display_name TEXT, 
    
    added_at INTEGER DEFAULT (unixepoch()),
    
    PRIMARY KEY (file_id, tag_id),
    FOREIGN KEY (file_id) REFERENCES files(file_id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(tag_id) ON DELETE CASCADE
);
```

---

## 4. Semantic Operations (The Contracts)

How standard POSIX commands translate to Graph Operations.

### A. The Inbox (`/magic/inbox`)
* **Definition:** The "Untagged" View.
* **Query:** `SELECT * FROM files f LEFT JOIN file_tags ft ON f.file_id = ft.file_id WHERE ft.tag_id IS NULL`.
* **Behavior:** When you add a tag to a file in the Inbox, it automatically **vanishes** from the Inbox (because it is no longer untagged).

### B. The Wastebin (`/magic/trash`)
* **Definition:** The "Black Hole".
* **System Tag:** `@trash` (ID: -1).
* **The Override Rule:** Any query for Tags, Search, or Inbox MUST include `AND NOT tags CONTAINS '@trash'`.
* **Behavior:**
    * `rm` inside `/trash`: Permanently deletes physical file and all DB references.
    * `mv file /magic/trash/`: Adds `@trash` tag. File vanishes from all other views.

### C. Copy (`cp`) = "Tagging"
* **Command:** `cp /magic/inbox/doc.pdf /magic/tags/finance/`
* **Logic:**
    1.  Resolve `doc.pdf` to `file_id=50`.
    2.  Resolve `/finance` to `tag_id=10`.
    3.  **Execute:** `INSERT INTO file_tags (file_id, tag_id) VALUES (50, 10)`.
* **Result:** File appears in Finance. Zero data duplicated.

### D. Move (`mv`) = "Retagging"
* **Command:** `mv /magic/tags/urgent/doc.pdf /magic/tags/done/`
* **Logic:**
    1.  **Transaction Start.**
    2.  `DELETE FROM file_tags WHERE file_id=50 AND tag_id=(SELECT id FROM tags WHERE name='urgent')`.
    3.  `INSERT INTO file_tags (file_id, tag_id) VALUES (50, (SELECT id FROM tags WHERE name='done'))`.
    4.  **Transaction Commit.**
* **Result:** File moves from Urgent to Done.

### E. Rename (`mv`) = "Aliasing"
* **Command:** `mv /magic/tags/finance/scan_001.pdf /magic/tags/finance/Invoice_Final.pdf`
* **Logic:**
    1.  Detect that Source Directory == Destination Directory.
    2.  **Execute:** `UPDATE file_tags SET display_name = 'Invoice_Final.pdf' WHERE file_id=50 AND tag_id=10`.
* **Result:** The file is renamed *only* in the Finance folder. It remains `scan_001.pdf` in the Warehouse and other tags.

---

## 5. Nested Logic (Venn Diagram)

* **Path:** `/magic/tags/finance/urgent/`
* **Logic:** This is **not** a physical folder. It is a generated view.
* **Query:** `SELECT * FROM files WHERE tags CONTAINS 'finance' AND tags CONTAINS 'urgent'`.
* **Tagging:** Dragging a file here executes **two** inserts: one for 'finance', one for 'urgent'.

---

## 6. Backup & Portability

* **Taxonomy:** `~/.config/magicfs/taxonomy.yaml` defines the tag colors, icons, and hierarchy logic.
* **State:** `~/.magicfs/index.db` contains all file relationships.
* **Backup Strategy:** Backing up `index.db` preserves the entire organizational brain.

---

## 7. View Generation & Collision Resolution

Since multiple files with the same `name` can exist in a single Tag View (e.g., five files named `log`), `readdir` must implement **Dynamic Disambiguation**.

### The Resolution Algorithm
1.  **Fetch Candidates:** `SELECT * FROM files WHERE tags...`
2.  **Detect Collisions:** Group results by `display_name` (or `name`).
3.  **For each Collision Group:**
    * **Attempt 1 (Tag Diff):** Append the first tag present on the file that is *not* part of the current view path.
        * *Format:* `name (tag).ext`
    * **Attempt 2 (Origin):** Append the immediate parent directory name of the physical file.
        * *Format:* `name (parent).ext`
    * **Attempt 3 (Timestamp):** Append YYYY-MM-DD.
        * *Format:* `name (date).ext`
    * **Attempt 4 (Hash):** Append first 4 chars of hash. (Last resort).
        * *Format:* `name [a1b2].ext`

### Inverse Lookup (Name Resolution)
The `InodeStore` must maintain a `view_cache` mapping the generated `virtual_filename` back to the `file_id` for `lookup/open` calls within that directory context.
